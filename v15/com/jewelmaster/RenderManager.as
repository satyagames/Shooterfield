package com.jewelmaster{	import com.terrypaton.events.GeneralEvents;	import com.terrypaton.events.PlayingLoopEvent;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.text.TextField;	import flash.display.MovieClip;	import flash.display.Sprite;	import com.terrypaton.utils.Broadcaster;	import com.jewelmaster.ObjectClass	import flash.geom.Matrix;	import flash.geom.Point;	import flash.geom.Rectangle;	import com.jewelmaster.settings	import com.atticmedia.console.*	import com.terrypaton.effect.particleManagerClass	import com.terrypaton.effect.particleClass	import com.terrypaton.effect.effectorClass	import com.gs.*	import com.terrypaton.effect.PixelateBitmap	public class RenderManager extends MovieClip {		public function RenderManager ():void {			_instance = this;			_DataManagerRef = DataManager.getInstance();			setupListeners ();			setupGraphics ();		}		private var _PixelateBitmapRef:PixelateBitmap = new PixelateBitmap();		public var pixelIt:Boolean				public static function getInstance ():RenderManager {			return _instance;		}		public function removeFirstPlayHelp():void {			try {				var _clip:MovieClip = MovieClip(getChildByName("firstPlayHelp"))				removeChild(_clip)			}catch (e:Error) {							}		}		public function showFirstPlayHelp():void {			var _clip:MovieClip = new firstPlayHelpClip()			addChild(_clip)			_clip.x = 240			_clip.y = -100			_clip.name = "firstPlayHelp"			TweenMax.to(_clip,.7,{y:240})			TweenMax.to(_clip,.7,{y:580,delay:3,overwrite:false,onComplete:removeFirstPlayHelp})		}		private var renderOffset:Point = new Point()		private var renderOffsetParam:int = int(443*.5)		private var renderOffsetParamMax:int = int(680-443)		public var showRevealLevel:Boolean		public var levelRevealCounter:int				public function renderGame ():void {			gameBitmapData.lock ()			gameBitmapData.fillRect (gameBitmapData.rect, 0x000000)			renderMatrix.identity ();			// get the data from the data manager and render it out to the screen			// work out where to offset the screen			_renderList = DataManager.getInstance().objectArray			n = _renderList.length			while (n--) {				_ObjectClass = _renderList[n]				if (_ObjectClass._active){					renderMatrix.identity ()					renderMatrix.scale(settings.RENDER_SCALE_FACTOR, settings.RENDER_SCALE_FACTOR)					var renderX:int = int(_ObjectClass._ix)					var renderY:int = int(_ObjectClass._iy)					renderMatrix.translate (renderX, renderY)					var _type:int = _ObjectClass._type										blitFrame = (_ObjectClass.getAnimationFrame ())					tempBitmapData = blitArray[blitFrame]					copyPixelsPoint.x = renderX - settings.RENDER_BLOCK_HALF_SIZE					copyPixelsPoint.y = renderY - settings.RENDER_BLOCK_HALF_SIZE					gameBitmapData.copyPixels(tempBitmapData,tempBitmapData.rect,copyPixelsPoint,null,null,true)				}			}			particleManagerRef.manageParticles (gameBitmapData, _effectSpriteSheet)			if (pixelIt) {				pixelAmount+=.5				_PixelateBitmapRef.process (gameBitmapData,Math.floor(pixelAmount))			}						gameBitmapData.unlock ()		}		private var revealClip:MovieClip = new levelRevealShape()		private var copyPixelsPoint:Point = new Point()		private var tempBitmapData:BitmapData		private var pixelAmount:Number= 0		private var blitFrame:int		public function particleEffect (_effectType : int, _xloc : int, _yloc : int) : void {			//////trace("particleEffect")			_ObjectClass = _DataManagerRef._PlayerClassRef			if (_ObjectClass._iy > renderOffsetParam ){				renderOffset.y = -_ObjectClass._iy +renderOffsetParam				if (renderOffset.y < -renderOffsetParamMax) {					renderOffset.y = -renderOffsetParamMax				}			}else {				renderOffset.y = 0			}			if (_ObjectClass._ix > renderOffsetParam ){				renderOffset.x = -_ObjectClass._ix +renderOffsetParam				if (renderOffset.x < -renderOffsetParamMax) {					renderOffset.x = -renderOffsetParamMax				}			}else {				renderOffset.x = 0			}			_xloc +=renderOffset.x			_yloc +=renderOffset.y				switch (_effectType)				{					case PARTICLE_EFFECT_ELECTRICAL_CHARGE :					particleManagerRef.createParticles (_xloc, _yloc, 2, P_ELECTRICAL)					particleManagerRef.createParticles (_xloc + Math.random () * 10 - 5, _yloc + Math.random () * 10 - 5, 1, P_BLUE_FLASH)					break					case PARTICLE_EFFECT_WELD :					particleManagerRef.createParticles (_xloc, _yloc, 1,P_LINE)					if (Math.random () * 10 < 2)					{						particleManagerRef.createParticles (_xloc, _yloc - 10, 1, P_WHITE_SMOKE)					}					if (Math.random () * 10 < 4)					{						//particleManagerRef.createParticles(_xloc + Math.random() * 10 - 5, _yloc + Math.random() * 10 - 5, 1, "flash")						particleManagerRef.createParticles (_xloc, _yloc, 1, P_FLICKER)					}					//particleManagerRef.createParticles(_xloc, _yloc, 1, "wandering line")					break					case PARTICLE_EFFECT_BLACK_SMOKE :					if (Math.random () * 10 < 6)					{						particleManagerRef.createParticles (_xloc, _yloc - 10, 1, P_BLACK_SMOKE)					}					break					case PARTICLE_EFFECT_SPARK :						particleManagerRef.createParticles (_xloc, _yloc, 2, P_WANDERING)						particleManagerRef.createParticles (_xloc, _yloc, 1, P_FLICKER)						particleManagerRef.createParticles (_xloc, _yloc, 1, P_GROWING)						particleManagerRef.createParticles (_xloc, _yloc - 10, 1, P_WHITE_SMOKE)					break					//case "battery dies":					//particleManagerRef.createParticles(_xloc, _yloc, 3, "smoke")					//particleManagerRef.createParticles(_xloc, _yloc, 3, "falling")					//break					case PARTICLE_EFFECT_WIRE_PICKEDUP :					particleManagerRef.createParticles (_xloc, _yloc, 1, P_WANDERING)					break					case PARTICLE_EFFECT_CHIP_PLACED :					particleManagerRef.createParticles (_xloc, _yloc, 1, P_FALLING)					particleManagerRef.createParticles (_xloc, _yloc, 1, P_WANDERING)					break					case PARTICLE_EFFECT_FLICKER :					particleManagerRef.createParticles (_xloc, _yloc, 1, P_FLICKER)					break				}					}		public static var particleManagerRef : particleManagerClass		public var _effectSpriteSheet : effectSpriteSheet		private static var PARTICLE_EFFECT_WELD : int = 0		private static var PARTICLE_EFFECT_SPARK : int = 1		private static var PARTICLE_EFFECT_WIRE_PICKEDUP : int = 2		private static var PARTICLE_EFFECT_CHIP_PLACED : int = 3		private static var PARTICLE_EFFECT_ELECTRICAL_CHARGE : int = 4		private static var PARTICLE_EFFECT_BLACK_SMOKE : int = 5		private static var PARTICLE_EFFECT_FLICKER : int = 6				private var P_ELECTRICAL:int = 1		private var P_WANDERING_LINE:int = 2		private var P_LINE:int = 3		private var P_FALLING:int = 4		private var P_WANDERING:int = 5		private var P_GROWING:int = 6		private var P_WHITE_SMOKE:int = 7		private var P_BLACK_SMOKE:int = 8		private var P_BLUE_FLASH:int = 9		private var P_FLASH:int = 10		private var P_FLICKER:int = 11				//private var gameScrollRect:Rectangle = new Rectangle(0,0,440,440)				private function setupGraphics () {			////trace("setupGraphics")			itemClip = new allItemsClip()			renderPlayerClip = new player()			gameBitmapData = new BitmapData(440+20, 440+20, false, 0xFF0000)			gameBitmap = new Bitmap (gameBitmapData)			//gameBitmap.scrollRect = gameScrollRect			addChild (gameBitmap)			//gameBitmap.width = gameBitmap.height = 443			gameBitmap.x =19			gameBitmap.y =19			_effectSpriteSheet = new effectSpriteSheet (300, 100)			particleManagerRef = new particleManagerClass ( )			_PixelateBitmapRef.setup(gameBitmapData)			// setup an array containing all the game graphics			blitArray = []			// blit the in game graphics			var n:int = itemClip.totalFrames +1			////trace("total frames = " + n)			blitArray = new Array()			var clipRect:Rectangle = new Rectangle(-settings.RENDER_BLOCK_HALF_SIZE,-settings.RENDER_BLOCK_HALF_SIZE,settings.RENDER_BLOCK_SIZE,settings.RENDER_BLOCK_SIZE)			for (var i:int = 1; i < n; i++) {				if (i <120 || i>130){					bmpData = new BitmapData (settings.RENDER_BLOCK_SIZE, settings.RENDER_BLOCK_SIZE, true, 0x00000000)					itemClip.gotoAndStop(i)					renderMatrix.identity()					renderMatrix.translate(22, 22)				}else {					bmpData = new BitmapData (settings.RENDER_BLOCK_SIZE*3, settings.RENDER_BLOCK_SIZE*3, true, 0x00000000)					itemClip.gotoAndStop(i)					renderMatrix.identity()					renderMatrix.translate(22*3, 22*3)				}				renderMatrix.scale(settings.RENDER_SCALE_FACTOR,settings.RENDER_SCALE_FACTOR)				//bmpData.draw(itemClip,renderMatrix,null,null,clipRect,true)				bmpData.draw(itemClip,renderMatrix,null,null,null,true)				blitArray[i] = bmpData			}			////trace("blitArray.length = "+blitArray.length)		}		private var bmpData:BitmapData		private var blitArray:Array		private function startPixelate (e:GeneralEvents) {			if (!pixelIt) {				////trace("startPixelate" )				pixelIt = true				pixelAmount = 2			}		}		private function resetPixelate (e:GeneralEvents) {			pixelIt = false			pixelAmount = 0			////trace("stop pixellate")		}		private function setupListeners () {			C.ch("render manager", "setupListeners()");			Broadcaster.addEventListener(GeneralEvents.START_PIXELATE,startPixelate)			Broadcaster.addEventListener(GeneralEvents.STOP_PIXELATE,resetPixelate)					}		private var itemClip:MovieClip		private var n:int		private var _renderList:Array		private var _tempPoint:Point = new Point()		private static var _instance:RenderManager;		private var _ObjectClass:ObjectClass;		private var renderPlayerClip:MovieClip;		private var gameBitmapData:BitmapData;		private var gameBitmap:Bitmap;		private var renderMatrix:Matrix = new Matrix();		private var _DataManagerRef:DataManager;		}}