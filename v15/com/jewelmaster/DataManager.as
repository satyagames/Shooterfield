package com.jewelmaster{	import flash.display.*;	import flash.events.MouseEvent;	import flash.events.TextEvent;	import flash.text.TextField;	import flash.ui.Mouse;	import flash.events.Event;	import flash.events.KeyboardEvent;	import com.terrypaton.utils.Broadcaster;	import com.terrypaton.events.PlayingLoopEvent;	import com.terrypaton.events.GeneralEvents;	import com.terrypaton.events.KeyBoardEvents;	import com.terrypaton.media.SoundManager;	import com.terrypaton.utils.commaNumber;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.geom.*;	import com.terrypaton.utils.Broadcaster;	import com.terrypaton.events.BoxEvents;	import com.jewelmaster.JewelMasterEvents;	import com.terrypaton.utils.SharedObjectManager;	import com.terrypaton.utils.SeededRandomNumber;	import com.terrypaton.utils.commaNumber;	import com.terrypaton.events.ButtonEvent;	import com.terrypaton.utils.Debug;	public class DataManager extends MovieClip {		public function DataManager(_holder:MovieClip):void {			_instance=this;			holder=_holder;			//_rootRef = TreasureCaves.getInstance();			_RenderManagerRef = new RenderManager();			_PlayingLoopManagerRef = new PlayingLoopManager ();			holder.addChild(_RenderManagerRef);			setupListeners();			addEventListener(Event.ENTER_FRAME, manageLoop, false, 0, true);			levelBmpData=new levelDesign(200,200);			_SeededRandomNumberRef = new SeededRandomNumber()			Broadcaster.addEventListener(KeyBoardEvents.KEY_PRESS, keyDownHandler);			Broadcaster.addEventListener (KeyBoardEvents.KEY_RELEASE, keyUpHandler);						holder.addEventListener(MouseEvent.MOUSE_DOWN,mouseDownHandler)			holder.addEventListener(MouseEvent.MOUSE_UP,mouseUpHandler)		}		private var mouseIsDrawing:Boolean		private var endMouseDrawX:int		private var endMouseDrawY:int		private var startMouseDrawX:int		private var startMouseDrawY:int		public function mouseDownHandler (event:Event) {			trace("_PlayingLoopManagerRef.gameState = "+_PlayingLoopManagerRef.gameState)			if (_PlayingLoopManagerRef.gameState == settings.GS_PLAYING){				if (mouseX > 20 && mouseX < 460) {					if (mouseY > 20 && mouseY < 460) {						mouseIsDrawing = true						startMouseDrawX = (mouseX - 20)/settings.RENDER_BLOCK_SIZE						startMouseDrawY = (mouseY - 20) / settings.RENDER_BLOCK_SIZE						//trace(startMouseDrawX,startMouseDrawY)					}				}			}		}		public function testForMatches ():void {			trace ("test for matches")			// scan through all rows for matches of 3 or more			var testObj:ObjectClass			//var i:int = 0			for (var i:int = 0; i < 10; i++) {				// first create a string of the types in current row				var rowString:String = ""								for (var j:int = 0; j < 10; j++) {					testObj = findItemAtLoc (j, i)					rowString += String(testObj._subtype)				}				trace ("row string = " + rowString)				// now go through every type of block and see if there is a match for that type				var jewelMatches:int = 0								var m:int = 0				for (var m:int = 0; m < 10;m++){					var matchString:String = rowString.slice (m, m + 1)					var explodeArray:Array = []					explodeArray.push(m)					for (var n:int = m + 1; n < 10;n++){						var nextString:String = rowString.slice (n, n + 1)						if (matchString == nextString) {							trace ("match! = " + matchString )							jewelMatches++							explodeArray.push(n)																			}else {							if (jewelMatches > 1) {								// tell the jewels in those postions to explode								var z:int = explodeArray.length								while (z--) {									var xx:int = explodeArray[z]									var expObj:ObjectClass = findItemAtLoc (xx, i)									expObj.destroy = true								}							}							n = 11							jewelMatches = 0						}					}				}			}		}		public function mouseUpHandler (event:Event) {			if (mouseIsDrawing){				if (mouseX > 20 && mouseX < 460 && mouseY > 20 && mouseY < 460) {						endMouseDrawX = (mouseX - 20)/settings.RENDER_BLOCK_SIZE						endMouseDrawY = (mouseY - 20) / settings.RENDER_BLOCK_SIZE						trace (endMouseDrawX, endMouseDrawY)						mouseIsDrawing = false						trace ("test if action is valid")						var validAction:Boolean = true												var xdist:int = startMouseDrawX - endMouseDrawX						var ydist:int = startMouseDrawY - endMouseDrawY						// is the start and end in the same place?						if (xdist == 0 && ydist == 0) {							validAction = false						}						// is the end location greater than a single square away?						if (Math.abs (xdist) > 1 || Math.abs (ydist) > 1) {							validAction = false						}																		if (!validAction) {							trace("NOT a valid action")						}else {							trace ("IS a valid action")							// tell the two peices in those locations to swap							//swapping							// find the two peices in the start and end location and tell them to swap							var obj1:ObjectClass = findItemAtLoc (startMouseDrawX, startMouseDrawY)							var obj2:ObjectClass =	findItemAtLoc(endMouseDrawX,endMouseDrawY)							obj1.swapping = true							obj1._basex = endMouseDrawX							obj1._basey = endMouseDrawY							obj1._targetx = endMouseDrawX * settings.RENDER_BLOCK_SIZE + settings.RENDER_BLOCK_HALF_SIZE							obj1._targety = endMouseDrawY * settings.RENDER_BLOCK_SIZE + settings.RENDER_BLOCK_HALF_SIZE														obj2.swapping = true							obj2._basex = startMouseDrawX							obj2._basey = startMouseDrawY							obj2._targetx = startMouseDrawX * settings.RENDER_BLOCK_SIZE + settings.RENDER_BLOCK_HALF_SIZE							obj2._targety = startMouseDrawY * settings.RENDER_BLOCK_SIZE + settings.RENDER_BLOCK_HALF_SIZE							_PlayingLoopManagerRef.gameState = settings.GS_SWAPPING						}									}else {					mouseIsDrawing = false				}			}		}		public function celebrateLevelComplete() {			var g:int=5;			while (g--) {				RenderManager.getInstance().particleEffect(4,Math.random()*680,Math.random()*680);			}		}		private function manageLoop(e:Event) {			_PlayingLoopManagerRef.manageLoop();		}		private function btnDownHandler(e:ButtonEvent):void {			//////trace(e.data.name)			switch (e.data.name) {				case "restartLevelBtn" :					// make the player lose life					if (! restartButtonDisabled) {						playerLosesALife();					}					break;			}		}		public function playerLosesALife():void {			//////trace("***playerLosesALife")			if (_PlayingLoopManagerRef.gameState==settings.GS_PLAYING) {				SoundManager.playSound("loseLife.wav");				restartButtonDisabled=true;				_PlayingLoopManagerRef.gameState=settings.GS_PLAYER_DEATH;				_PlayerClassRef.current_state=settings.PS_DIE;				_PlayerClassRef.playerDies();				lives--;				var totalLivesLost:int=SharedObjectManager.getInstance().getData("livesLost");				totalLivesLost++;				if (totalLivesLost==100) {					_data.medalUnlocked=settings.MEDAL_DIED_100_DEATHS;					Broadcaster.dispatchEvent(new JewelMasterEvents(JewelMasterEvents.MEDAL_UNLOCKED, true, _data));				}				SharedObjectManager.getInstance().setData("livesLost",totalLivesLost);				holder.HUDClip.livesTextBox.text=lives;			}		}		public function setLevel(e:PlayingLoopEvent):void {			level=int(e.data.startOnLevel);		}		public function setupNewGame(e:PlayingLoopEvent):void {			restartButtonDisabled=true;			lastLevelCompleted = -1			lives=3;			Broadcaster.addEventListener(KeyBoardEvents.KEY_PRESS, keyDownHandler);			Broadcaster.addEventListener(KeyBoardEvents.KEY_RELEASE, keyUpHandler);			setupLevel();			// test for 200 games played			var gamesPlayed:int=SharedObjectManager.getInstance().getData("gamesPlayed");			gamesPlayed++;			if (gamesPlayed==200) {				_data.medalUnlocked=settings.MEDAL_200_GAMES_PLAYED;				Broadcaster.dispatchEvent(new JewelMasterEvents(JewelMasterEvents.MEDAL_UNLOCKED, true, _data));			}			SharedObjectManager.getInstance().setData("gamesPlayed", gamesPlayed);			totalTreasureCollected=SharedObjectManager.getInstance().getData("totalTreasureCollected");		}		private var totalTreasureCollected:int;		public function setupLevel() {			restartButtonDisabled=false;			var ci:int=_SeededRandomNumberRef.seed=level;			holder.HUDClip.levelTextBox.text=level;			objectArray=[];			// get level data						var levelData:Array=[];			objectArray = new Array ();			var type:int;			var _subtype:int;			for (var i:int = 0; i < 10; i++) {				for (var j:int = 0; j < 10; j++) {					_subtype=1;					type = settings.TREASURE;					var xp:Number = (j* settings.RENDER_BLOCK_SIZE)+settings.RENDER_BLOCK_HALF_SIZE;					var yp:Number = (i * settings.RENDER_BLOCK_SIZE)+settings.RENDER_BLOCK_HALF_SIZE;					createObject(j, i, xp, yp, type,_subtype);				}			}			levelItemsCollected=0;			holder.HUDClip.livesTextBox.text=lives;			holder.HUDClip.scoreTextBox.text = commaNumber.processNumber(score);			CoreDataManager.getInstance().score = score			if (level==1&&! firstPlayHelpShown) {				firstPlayHelpShown=true;				_RenderManagerRef.showFirstPlayHelp();				SoundManager.playSound("message.wav");			}			_RenderManagerRef.showRevealLevel=true;			_RenderManagerRef.levelRevealCounter=1;		}		public function dispose():void {			Broadcaster.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			Broadcaster.removeEventListener(KeyboardEvent.KEY_UP, keyUpHandler);			Broadcaster.removeEventListener(PlayingLoopEvent.SETUP_NEW_GAME, setupNewGame);					}		private function setupListeners() {			Broadcaster.addEventListener(PlayingLoopEvent.SETUP_NEW_GAME, setupNewGame);			Broadcaster.addEventListener(JewelMasterEvents.SET_LEVEL,setLevel);			Broadcaster.addEventListener(ButtonEvent.DOWN,btnDownHandler);		}		private function createObject(_basex:int,_basey:int,_xLoc:Number, _yLoc:Number, _type:int,_subtype:int = 0):ObjectClass {			switch (_type) {				case settings.EXIT :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,0,0);					break;				case settings.DIRT :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,_SeededRandomNumberRef.nextIntRange(0,18),1);					break;				case settings.ROCK :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,_SeededRandomNumberRef.nextIntRange(0,9),1);					break;				case settings.BOULDER :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,_SeededRandomNumberRef.nextIntRange(0,9),1);					break;				case settings.TREASURE :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,_SeededRandomNumberRef.nextIntRange(0,9),1);					break;				case settings.DIAMOND :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,_SeededRandomNumberRef.nextIntRange(0,9),1);					break;				case settings.MOVING_ENEMY :					_ObjectClassRef=new MovingEnemyClass(_basex,_basey,_xLoc,_yLoc,_type,_subtype,1);					break;				default :					_ObjectClassRef=new ObjectClass(_basex,_basey,_xLoc,_yLoc,_type,1,1);					break;			}			objectArray.push(_ObjectClassRef);			return _ObjectClassRef;		}				private function addPoints(_num:int):void {			score += _num;			CoreDataManager.getInstance().score = score			////////trace(holder)			holder.HUDClip.scoreTextBox.text=commaNumber.processNumber(score);		}		private function findItemAtLoc(_testx:int, _testy:int):ObjectClass {			var n:int=objectArray.length;			while (n--) {				var _ObjectClassRef:ObjectClass=objectArray[n];				if (! _ObjectClassRef.destroy) {					if (_ObjectClassRef._nextbasex==_testx||_ObjectClassRef._basex==_testx) {						if (_ObjectClassRef._nextbasey==_testy||_ObjectClassRef._basey==_testy) {							return _ObjectClassRef;						}					}				}			}			return null;		}		public function testExitLevel():Boolean {			////trace ("testing if the player is allowed ot exit")			if (levelItemsCollected>=levelItemsToCollect) {				return true;			} else {				return false;			}		}		public function Update():void {			// process all objects			if (_PlayingLoopManagerRef.gameState==settings.GS_PLAYING||_PlayingLoopManagerRef.gameState==settings.GS_PLAYER_DEATH_WAIT||_PlayingLoopManagerRef.gameState==settings.GS_SWAPPING||_PlayingLoopManagerRef.gameState==settings.GS_SWAPPING_WAIT) {				manageObjects();			}			// render			_RenderManagerRef.renderGame();		}		private var difx:Number		private var dify:Number		public function manageObjects():void {			////////trace(_PlayerClassRef._type)			var o:int=objectArray.length;			testItem=null;			////////trace(n)			while (o--) {				//if (o>-1) {				manageItemRef=objectArray[o];				if (manageItemRef.destroy) {					objectArray.splice(o,1);				} else {					switch (manageItemRef._type) {						case settings.TREASURE :												if (manageItemRef.swapping) {								 difx = (manageItemRef._targetx - manageItemRef._ix)								 dify = (manageItemRef._targety - manageItemRef._iy)								if (Math.abs (difx) < .5 && Math.abs (dify) < .5 ) {									manageItemRef.swapping = false									manageItemRef._ix = manageItemRef._targetx									manageItemRef._iy = manageItemRef._targety								}else {									manageItemRef._ix+=difx*.9									manageItemRef._iy+=dify*.9								}							}else if (manageItemRef.falling==false) {								if (manageItemRef._basey < 9) {									// test if the DIAMOND can fall									testItem = findItemAtLoc (manageItemRef._basex, manageItemRef._basey + 1)									if (testItem==null||! testItem._active) {										manageItemRef.falling=true;										manageItemRef._nextbasey=manageItemRef._basey+1;									} else {										manageItemRef._iy=manageItemRef._basey*settings.RENDER_BLOCK_SIZE+settings.RENDER_BLOCK_HALF_SIZE;										manageItemRef.yspeed=0;									}								}							} else {								// object is moving								if (manageItemRef.yspeed<6) {									manageItemRef.yspeed+=1.5;								}								manageItemRef._iy+=manageItemRef.yspeed;								testYLoc=manageItemRef._basey+1;								nextYLoc=testYLoc*settings.RENDER_BLOCK_SIZE+settings.RENDER_BLOCK_HALF_SIZE;								// update the object to move between grid locations								// when the object moves to the next square update it's baseY								if (manageItemRef._iy>nextYLoc) {									manageItemRef._basey=testYLoc;									manageItemRef.falling=false;									manageItemRef._nextbasey=-1;									// if it can't fall any further, then make it stop, other wise keep it moving									//SoundManager.playSound("itemLands.wav");								}								if (testYLoc>9) {									manageItemRef.falling=false;								}							}							break;					}					//}				}			}		}		public function keyDownHandler(event:KeyBoardEvents):void {			////////trace(event.data.keyCode)			//			switch (event.data.keyCode) {				case 32 :// space					break;				case 192 :					DisplayManager.getInstance().sprite_StatsSprite.visible=! DisplayManager.getInstance().sprite_StatsSprite.visible;					////////trace(statsSprite)					break;			}		}		public function keyUpHandler(event:KeyBoardEvents):void {			////////trace(event.keyCode)			switch (event.data.keyCode) {							case 32 :// space					break;				case 192 :					//statsSprite.visible=! statsSprite.visible;					////////trace(statsSprite)					break;			}		}				public static function getInstance():DataManager {			return _instance;		}		private var _PlayingLoopManagerRef:PlayingLoopManager;		private var _RenderManagerRef:RenderManager;		private static var _instance:DataManager;		public var level:int=1;		private var renderXSpot:Number;		private var renderYSpot:Number;		private var firstPlayHelpShown:Boolean=false;		private var tempPoint:Point = new Point();		private var _data:Object = new Object();		public var score:int=0;		public var lives:int;		private var restartButtonDisabled:Boolean;		public var lastLevelCompleted:int=-1;		private var dif:Number;		private var testRollXLoc:int;		private var testForItem:ObjectClass;		private var xdist:int;		private var ydist:int;		private var tempx:int;		private var tempy:int;		private var xp:Number;		private var yp:Number;		private var testYLoc:int;		private var nextYLoc:int;				private var playerStartX:int=0;		private var playerStartY:int=0;		private var levelBmpData:BitmapData;		private var testItem:ObjectClass;		private var levelItemsToCollect:int;		private var levelItemsCollected:int;		public var renderList:Array = new Array ();		//public var _renderItem:renderItem;		private var nextXLoc:int;		private var playerMoving:Boolean;		private var destroy:Boolean;		private var rightPressed:Boolean;		private var leftPressed:Boolean;		private var downPressed:Boolean;		private var upPressed:Boolean;		private var playerClip:MovieClip;		private var playerX:Number=0;		private var playerY:Number=0;		public var objectArray:Array;		public var startOnLevel:int=1;		private var _clip:MovieClip;		private var _ObjectClassRef:ObjectClass;		public var _PlayerClassRef:PlayerClass;		private var n:int;		private var playerBaseX:int;		private var playerBaseY:int;		private var moveXDiff:Number;		private var moveYDiff:Number;		private var playerXMoveTarget:Number;		private var playerYMoveTarget:Number;		private var o:int;		private var manageItemRef:ObjectClass;		private var holder:MovieClip;		private var _SeededRandomNumberRef:SeededRandomNumber;	}}